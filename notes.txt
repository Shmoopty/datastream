for ( int i = 1; i < dependency_graph_.size(); i++ ){

	auto set_search = schema_set_ptr_map.find(
		dependency_graph_.at(i)
	);

	if ( set_search == schema_set_ptr_map.end()){
		throw std::domain_error("sorry, the data cannot be understood : a section is missing.");
	}

	auto parent_search = schema_set_ptr_map.find(set_search->second->parent());
	if ( parent_search == schema_set_ptr_map.end()){
		throw std::domain_error("sorry, the data cannot be understood : a section is missing.");
	}
	parent_search->second->connect(*set_search->second);

}




determine that there is one root


traverse set via parent child relationship

if cyclic fail

if list size = num sets, pass and you have sorted dependancy graph



parameters

action
output format

request parameters
parameters





access from friend class only



multi iterator range based for
on variadic template



template <typename T>
typename std::enable_if<is_row_containter<T>::value>::type
friend writeRows(T const& rows )
{
	for (auto& row : rows) {
		std::cout << deref(row).id << " has parent " << deref(row).parent << std::endl;
	}
}


redo this:

data_set.h 71

void weave(DataSet& parent_set)
{
	for(DataRow& row : rows )
	{
		// parent id may match multiple rows
		// ids are present in the data
		// not by this process
		// this process must handle cases where id is not unique

		auto parent_rows_search = parent_set.id_to_rows_map.find(row.parent);
		if(parent_rows_search != parent_set.id_to_rows_map.end()){
			auto parent_rows = parent_rows_search->second;

			for(DataRow* parent_row : parent_rows)
			{
				parent_row->nestChildRow(id(), row);
			}
		}
	}
}


'shared_ptr<std::__1::vector<datastream::DataRow *,
	 std::__1::allocator<datastream::DataRow *> >>' to '

	 const shared_ptr<datastream::DataRow *>' for 2nd argument

   pair(const _T1& __x, const _T2& __y)

   // if (parent_id_to_rows_map.find(row_ptr->parent) == parent_id_to_rows_map.end()){
   // 	//parent_id_to_rows_map.emplace_hint(
   //
   // 	//	parent_id_to_rows_map.end(),
   // 		row_ptr->parent,
   // 		//std::shared_ptr<SceneNode>(subnode_p)
   // 		std::shared_ptr<vector<DataRow*>> (new vector<DataRow*>{row_ptr})
   // 	);
   // }
   // else{
   // 	///parent_id_to_rows_map[row_ptr->id].push_back(row_ptr);
   // }





   // if (parent_id_to_rows_map.find(row_ptr->parent) == parent_id_to_rows_map.end()){
   // 	//parent_id_to_rows_map.emplace_hint(
   // 	parent_id_to_rows_map.emplace(
   // 	//	parent_id_to_rows_map.end(),
   // 		row_ptr->parent,
   // 		//std::shared_ptr<SceneNode>(subnode_p)
   // 		std::shared_ptr<vector<DataRow*>> (new vector<DataRow*>{row_ptr})
   // 	);
   // }
   // else{
   // 	///parent_id_to_rows_map[row_ptr->id].push_back(row_ptr);
   // }




// std::shared_ptr<vector<DataRow*>> sp (new vector<DataRow*>{row_ptr});
//
//  std::pair < unsigned int , std::shared_ptr<vector<DataRow*>>> p
//  = std::make_pair (row_ptr->parent , sp );
//
//  parent_id_to_rows_map.insert (
// 	 parent_id_to_rows_map.end(),
//   	 sp
//);

// parent_id_to_rows_map.emplace(
// 	row_ptr->parent,
// 	sp
// );



// the schema tells us which sets nest within the current set

// we use the integer id from the child set to retrieve rows
// from a map which is a member of this object

// why such a convoluted path to the data we alreay have in this object?

// 1.
// because there may not be any child rows in the data for this row,
// but we still may want to add an empty label

// 2.
// because this ensures that the sets are presented in the correct order
// not the order which the map is sorted


// map
// schema sets are stored in list container
// this guarantees items will not be moved
// and pointers to these objects will reliable
// but it does not permit us fast random access
// for this purpose a map of pointers is created
//
// this should always we quick, not enough rows to be focus of optimisation
// but could try re factoring so it can occur after loadElementSchema
// to end database connection sooner
//
// cyclic references are prevented because tree mapped from child to parent
// but read parent to child.
// as root will not be connected to a parent, any cyclic references are not traversed





// some day we are going to need this.
// but if you use it you need to be aware
// of the possible consequences

// advanced features
// use at your peril
// expect that when used for json
// schema validator will require:

// hide_when_empty to true
// when
// SetWrappper : no_wrapper
// expect that when used for json or xml
// schema validator will require:

// limit_single_child to true
// when
// rowWrapper : no_wrapper



template <typename Container1, typename Container2>
void for_each_together(
  Container1 &c1,
  Container2 &c2,
  std::function<void(Container1::iterator &it1, Container2::iterator &it2)> f)
{
  Container1::iterator begin1 = c1.begin();
  Container2::iterator begin2 = c2.begin();
  Container1::iterator end1 = c1.end();
  Container2::iterator end2 = c2.end();
  Container1::iterator i1;
  Container1::iterator i2;
  for (i1 = begin1, i2 = begin2;
	  (i1 != end1) && (i2 != end2);
	  ++it1, ++i2) {
		f(i1, i2);
	}
}



for_each_together(
	schema_set.child_elements,
	child_elements,

	[&](auto& schema_child, auto& data_child ){
		formatter.writeElement(
			os,
			schema_child.name,
			data_child.getValue(),
			data_child.isNull(),
			schema_child.data_type,

			//parent row wrapper
			schema_set.rowWrapper,
			children_written
		);
		++children_written;
	}

)
