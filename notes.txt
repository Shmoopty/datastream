
hide on empty for elements

test array in array etc

test null values





the_map[x] = boost::reference_wrapper<T>(ZZ);

the_map.insert(make_pair(x, ZZ));







group wrapper
[

]

or

none

row wrapper

{
	object
	=> elements need labels
}

[
	array
	=> elements do not need lables is json
]

none















/*
// why not call label seperately?
// isn't label is part of parent?
// yes in json
// but hide on empty logic crosses parent / child boundry

if(data_child_rows_it == data_child_rows_by_set_id_map.end()){
	if(!(*schema_child_set_it)->hide_when_empty){

		//label


		// formatter.writeEmptyGroup(
		// 	os,
		// 	(*schema_child_set_it)->group_name,
		// 	(*schema_child_set_it)->row_name,
		// 	blank,
		// 	true,
		// 	ElementDataType::type_raw,
		// 	children_written,
		//
		// 	//parent row wrapper
		// 	schema_set.rowWrapper,
		// 	(*schema_child_set_it)->groupWrapper
		//
		//
		// 	//if group unwrapped : null
		// 	//if group wrapped: []
		//
		// );

		++children_written;
	}
	continue;
}

// map was created in this class,
// so trust that if vector exists it contains at least one row


// call label seperately
// group should not include label, label is part of parent

// refactor this out to seperate call
// with vector of child rows
// then logic above with null rows can be called with empty vector?
// no it can't logic for hide on empty crosses parent child boundry
// formatter.openGroup(
// 	os,
// 	(*schema_child_set_it)->group_name,
// 	(*schema_child_set_it)->row_name,
// 	first,
// 	//parent row wrapper
// 	schema_set.rowWrapper,
// 	(*schema_child_set_it)->groupWrapper
// );

bool first_child_row = true;

if(data_child_rows_it != data_child_rows_by_set_id_map.end()){

	auto child_row_ptr_it = data_child_rows_it->second.begin();

	// while (child_row_ptr_it != data_child_rows_it->second.end()){
	//
	// 	//recursive call to self
	// 	(*child_row_ptr_it)->write(os, **schema_child_set_it, formatter, first);
	//
	// 	child_row_ptr_it++;
	// 	first_child_row = false;
	//
	// 	if((*schema_child_set_it)->limit_single_child  ){
	// 		break;
	// 	}
	// }
}
*/
//CLOSE GROUP
//formatter.closeElement(os, (*schema_child_set_it)->name, (*schema_child_set_it)->no_array_wrapper_around_group);

// formatter.closeGroup(
// 	os,
// 	(*schema_child_set_it)->group_name,
// 	(*schema_child_set_it)->row_name,
// 	//parent row wrapper
// 	schema_set.rowWrapper,
// 	(*schema_child_set_it)->groupWrapper
// );









				// std::cout << " ------------------\n";
				// std::cout << line << "\n";
				//
				// for (int i = 0; (i < matched.length()) && (i <= 10) ; ++i){
				// 	std::cout << i << ": " << matched[i]  << "\n";
				// }


				// std::cout << "\n";
				// std::cout << matched[match_index_id]  << "\n";
				// std::cout << matched[match_index_parent]  << "\n";
				// std::cout << matched[match_index_value]  << "\n";
				// std::cout << matched[match_index_input_filename]  << "\n";
				// std::cout << matched[match_index_single]  << "\n";
				// std::cout << matched[match_index_no_array_around_group]  << "\n";
				//
				//




								std::cout << "\n";
								std::cout << matched[match_index_schema_id]  << "\n";
								std::cout << matched[match_index_schema_parent]  << "\n";
								std::cout << matched[match_index_group_name]  << "\n";
								std::cout << matched[match_index_row_name]  << "\n";
								std::cout << matched[match_index_input_filename]  << "\n";
								std::cout << matched[match_index_is_root]  << "\n";

								std::cout << matched[match_index_hide_when_empty]  << "\n";
								std::cout << matched[match_force_single_row_per_parent]  << "\n";
								std::cout << matched[match_group_wrapper_type]  << "\n";
								std::cout << matched[match_row_wrapper_type]  << "\n";



												std::cout << " ------------------\n";
												std::cout << line << "\n";

												for (int i = 0; (i < matched.length()) && (i <= 10) ; ++i){
													std::cout << i << ": " << matched[i]  << "\n";
												}



														const string tab = "  ";
														const string newline = "\n";
														const string blank = "";
														const string comma = ",";
														const string double_quote = "\"";
														const string open_brace = "{";
														const string close_brace = "}";
														const string open_bracket = "[";
														const string close_bracket = "]";




																		virtual void writeElement(
																			ostream & os,
																			const string& name,
																			const string& value,
																			bool isNull,
																			ElementDataType data_type,
																			RowWrapper row_wrapper,
																			bool first


																		//WRITE CHILD

																		enum class GroupWrapper {
																			array_wrapper,
																			no_wrapper
																		};

																		if (schema_set.rowWrapper = RowWrapper::no_wrapper){
																			formatter.writeValue(
																				os,
																				blank,
																				data_child_element_it->getValue(),
																				data_child_element_it->isNull(),
																				schema_child_element_it->data_type,
																				first
																			);
																		}
																		else{



																		formatter.openGroup(
																			os,
																			(*schema_child_set_it)->group_name,
																			(*schema_child_set_it)->row_name,
																			blank,
																			true,
																			first,
																			(*schema_child_set_it)->groupWrapper,
																			(*schema_child_set_it)->rowWrapper
																		);

																		formatter.writeValue(os, blank, blank, true, ElementDataType::type_raw,  first);
																		first = false;






																						// auto data_child_rows_it = data_child_rows_by_set_id_map.find((*schema_child_set_it)->id);
																						//
																						// // i don't this this can happen but lets be careful
																						// if(data_child_rows_it == data_child_rows_by_set_id_map.end()){
																						// 	if(!(*schema_child_set_it)->hide_when_empty){
																						// 		formatter.writeSimpleGroup(
																						// 			os,
																						// 			(*schema_child_set_it)->group_name,
																						// 			(*schema_child_set_it)->row_name,
																						// 			blank,
																						// 			true,
																						// 			ElementDataType::type_raw,
																						// 			first,
																						// 			(*schema_child_set_it)->groupWrapper,
																						// 			(*schema_child_set_it)->rowWrapper
																						// 		);
																						// 		first = false;
																						// 	}
																						// 	continue;
																						// }


																							bool first_child_row = true;

																						list<SchemaSet>::iterator & schema_set_it



																						else
																						{

																						}
																						//WRITE SET
																						//FACTOR OUT

																						formatter.openGroup(
																							os,
																							(*schema_child_set_it)->group_name,
																							(*schema_child_set_it)->row_name,
																							first,
																							(*schema_child_set_it)->groupWrapper,
																							(*schema_child_set_it)->rowWrapper
																						);



																						//does child dataset have rows?
																						auto data_child_rows_it = data_child_rows_by_set_id_map.find((*schema_child_set_it)->id);

																						bool first_child_row = true;

																						if(data_child_rows_it != data_child_rows_by_set_id_map.end()){

																							auto child_row_ptr_it = data_child_rows_it->second.begin();

																							while (child_row_ptr_it != data_child_rows_it->second.end()){

																								cout << "x";
																								formatter.openRow(
																									os,
																									(*schema_child_set_it)->name,
																									first_child_row,
																									(*schema_child_set_it)->no_object_wrapper_around_row,
																									(*schema_child_set_it)->array_wrap_around_row

																								);
																								cout << "z";
																								//recursive call to self
																								(*child_row_ptr_it)->write(os, **schema_child_set_it, formatter, first);

																								formatter.closeRow(
																									os,
																									(*schema_child_set_it)->name,
																									(*schema_child_set_it)->no_object_wrapper_around_row,
																									(*schema_child_set_it)->array_wrap_around_row
																								);

																								if((*schema_child_set_it)->limit_single_child  ){
																									break;
																								}
																								child_row_ptr_it++;
																								first_child_row = false;
																							}
																						}


																						//FRAGILE
																						// this catches child sets that have been written without an array wrapper that have no rows
																						// without adding 'null'
																						// this would be invalid json
																						else{
																							if ((*schema_child_set_it)->no_array_wrapper_around_group){
																								formatter.writeValue(os, blank, blank, true, ElementDataType::type_raw,  first);
																							}
																						}

																						//CLOSE GROUP
																						formatter.closeElement(os, (*schema_child_set_it)->name, (*schema_child_set_it)->no_array_wrapper_around_group);




																						std::cout  << "group : ";
																						if (groupWrapper == GroupWrapper::array_wrapper){
																							//stepDown(os);
																							std::cout  << "array\n";
																						}
																						else if (groupWrapper == GroupWrapper::no_wrapper){
																							//stepDown(os);
																							std::cout  << "none\n";
																						}

																						std::cout  << "row : ";
																						if (rowWrapper == RowWrapper::object_wrapper){
																							//stepDown(os);
																							std::cout  << "object\n";
																						}
																						else if (rowWrapper == RowWrapper::array_wrapper){
																							//stepDown(os);
																							std::cout  << "array\n";
																						}
																						else if (rowWrapper == RowWrapper::no_wrapper){
																							//stepDown(os);
																							std::cout  << "none\n";
																						}






																							//typedef SchemaSet* SchemaSetPtr;
																							//typedef map<int, SchemaSet> SchemaSetPtrs;

																							//

																							//map<int, SchemaSet>

																							//using MappedSet = std::map<int, std::reference_wrapper<SchemaSet>>


																							// typedef list<SchemaElement> SchemaElements;
																							// typedef SchemaElement* SchemaElementPtr;
																							// typedef vector<SchemaElementPtr> SchemaElementPtrs;
																							class SchemaSet;

//typedef SchemaSet* SchemaSetPtr;
// typedef list<SchemaSet> list<SchemaSet>;

//typedef map<int, SchemaSet*> SchemaSetPtrs;


// for (
// 	auto
// 	schema_set_it = schema_set_list.begin();
// 	schema_set_it != schema_set_list.end();
// 	++schema_set_it
// ){
// 	schema_set_ptr_map.emplace(
// 		int(schema_set_it->id),
// 		SchemaSetPtr(&(*schema_set_it))
// 	);
// }







			//std::vector<std::reference_wrapper<SchemaSet>> v (schema_set_list.begin(), schema_set_list.end());

			//std::sort(v.begin(),v.end() , [](SchemaSet& a,  SchemaSet& b)->bool{ return a.id < b.id; });


			//std::sort(intArr, intArr + len -1, [](int a, int b)




			//SchemaSetPtrs schema_set_ptrs_2;

			// auto fp = []( SchemaSet& schema_set)->std::pair<int, SchemaSetPtr>{
			// 	return std::make_pair(schema_set.id, &schema_set);
			// };
			//
			// SchemaSetPtrs schema_set_ptrs_2 = std::map<int, SchemaSetPtr> (
			// 	boost::make_transform_iterator(schema_set_list.begin(), fp),
			// 	boost::make_transform_iterator(schema_set_list.end(),   fp )
			// );

			// auto fp = []( SchemaSet& schema_set)->std::pair<int, SchemaSetPtr>{
			// 	return make_pair(schema_set.id, &schema_set);
			// };
			//


			// auto f = []( SchemaSet& schema_set)->std::pair<int, std::reference_wrapper<SchemaSet>>{
			// 	return make_pair(schema_set.id, std::ref(schema_set));
			// };





			//
			// schema_set_map = std::map<int, std::reference_wrapper<SchemaSet>> (
			// 	boost::make_transform_iterator(schema_set_list.begin(), f),
			// 	boost::make_transform_iterator(schema_set_list.end(),   f )
			// );

			 //std::transform (schema_set_list.begin(), schema_set_list.end(), schema_set_map.begin(), f);

			// for (auto& mi : schema_set_map) {
			// 	std::cout << mi.first << " has value " << mi.second.get().group_name << std::endl;
			// }

			// for insert into map<int, std::reference_wrapper<SchemaSet>>

	    	// auto f = [](SchemaSet&& schema_set) {
			// 	return make_pair(schema_set.id, std::ref(schema_set));
			// };
			//
			// map<int, std::reference_wrapper<SchemaSet>> m (
			// 	boost::make_transform_iterator(schema_set_list.begin(), f),
		    //     boost::make_transform_iterator(schema_set_list.end(), f)
			// );
			// //schema_set_refs =


			//auto set_search = schema_set_map.find(element_set_id);
			//auto set_search = schema_set_map.find(element_set_id);

							// std::cout << " ------------------\n";
							// std::cout << line << "\n";
							//
							// for (int i = 0; (i < matched.length()) && (i <= 10) ; ++i){
							// 	std::cout << i << ": " << matched[i]  << "\n";
							// }

// for(
// 	auto schema_set_it = schema_set_list.begin();
// 	schema_set_it != schema_set_list.end();
// 	++schema_set_it
// ) {
//
// 	// root has no parent - do not weave
// 	if (schema_set_it->isRoot()){
// 		continue;
// 	}
//
// 	int parent_set_id = schema_set_it->parent;
//
// 	if (schema_set_ptr_map.find(parent_set_id) == schema_set_ptr_map.end()){
// 		throw std::domain_error("the data schema is not valid, parent not found");
// 	}
// 	schema_set_ptr_map[parent_set_id]->nestChildSet(&(*schema_set_it));
// }

/* not currently used

		void setValue (string&& v)
		{
			value = v;
		}

		void setValue (const string& v)
		{
			value = v;
		}

		void setNull (bool n)
		{
			null_value = n;
			if (n){
				value = blank;
			}
		}
*/




//sort by id for fast insert into map
sort(
	dot_ptrs.begin(),
	dot_ptrs.end(),
	[](Dot * a,  Dot * b)->bool
	{
		return a->id < b->id;
	}
);

//insert pairs into map
for ( Dot * dot_ptr : dot_ptrs ){
	dot_ptr_map.emplace_hint(
		dot_ptr_map.end(),
		int(dot_ptr->id),
		dot_ptr
	);
}



The c++11 range based for is nice:

    for (lick : ice_cream){
        lickIceCream(lick);
    }

any way to use it to iterate over two containers?

    auto hotdog_it = hotdogs.begin();
	auto bun_it = buns.begin();

	for(;
		hotdog_it != hotdogs.end() &&
		bun_it != buns.end();

		hotdog_it++,
		bun_it++

	){
		mouth.putIn(assemble(bun_it(hotdog_it),{onions(),mustard()}));
	}
